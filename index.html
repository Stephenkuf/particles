<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive 3D Particles - Hand Control</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      color: white;
    }

    /* Video feed (Hidden or Small Corner for debugging) */
    #video-feed {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 150px;
      border-radius: 12px;
      transform: scaleX(-1);
      /* Mirror effect */
      opacity: 0.8;
      border: 2px solid rgba(255, 255, 255, 0.2);
      z-index: 10;
    }

    /* Modern Glassmorphism UI */
    #ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 280px;
      padding: 20px;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
      z-index: 100;
      transition: all 0.3s ease;
    }

    h1 {
      font-size: 1.2rem;
      margin-top: 0;
      margin-bottom: 15px;
      font-weight: 600;
      background: linear-gradient(90deg, #00f260, #0575E6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .control-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 8px;
      color: #aaa;
    }

    /* Shape Buttons */
    .shape-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    button {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #eee;
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      font-size: 0.85rem;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    button.active {
      background: #0575E6;
      border-color: #0575E6;
      color: white;
    }

    /* Color Picker */
    input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }

    /* Status Indicator */
    #status {
      font-size: 0.8rem;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #ff4444;
    }

    .dot.active {
      background-color: #00f260;
      box-shadow: 0 0 8px #00f260;
    }
  </style>

  <!-- Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

  <!-- Video Element for MediaPipe (Hidden logic handled in script) -->
  <video id="video-feed" playsinline></video>

  <!-- UI Panel -->
  <div id="ui-panel">
    <h1>Particle Morph</h1>

    <div class="control-group">
      <label>Select Template</label>
      <div class="shape-grid">
        <button onclick="setShape('heart')" class="active" id="btn-heart">Heart</button>
        <button onclick="setShape('saturn')" id="btn-saturn">Saturn</button>
        <button onclick="setShape('flower')" id="btn-flower">Flower</button>
        <button onclick="setShape('buddha')" id="btn-buddha">Statue</button>
        <button onclick="setShape('fireworks')" id="btn-fireworks">Fireworks</button>
        <button onclick="setShape('sphere')" id="btn-sphere">Sphere</button>
      </div>
    </div>

    <div class="control-group">
      <label>Particle Color</label>
      <input type="color" id="color-picker" value="#ff0055">
    </div>

    <div id="status">
      <div class="dot" id="cam-dot"></div>
      <span id="status-text">Waiting for camera...</span>
    </div>
    <div style="font-size: 0.75rem; color: #777; margin-top: 5px;">
      Open Hand = Expand <br> Closed Fist = Contract
    </div>
  </div>

  <script>
    // --- 1. CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.08;
    let currentShape = 'heart';
    let handInteractionFactor = 1.0; // 1 = Open, 0 = Closed

    // --- 2. THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 8;
    camera.position.y = 1;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 3. PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 20;
      targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Create a soft circle texture for particles
    const getSprite = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, 32, 32);
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      return texture;
    };

    const material = new THREE.PointsMaterial({
      color: 0xff0055,
      size: PARTICLE_SIZE,
      map: getSprite(),
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 4. SHAPE GENERATORS (MATH) ---

    function getPointOnSphere(r) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
      };
    }

    function generateShapePositions(shape) {
      const newArr = new Float32Array(PARTICLE_COUNT * 3);

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x, y, z;
        const idx = i * 3;

        if (shape === 'heart') {
          // Parametric Heart
          let t = Math.random() * Math.PI * 2; // theta
          let p = Math.random() * Math.PI;     // phi
          // Distribute mainly on surface but some volume
          let r = 0.5 + Math.random() * 0.1;

          // Specific heart formula
          x = 16 * Math.pow(Math.sin(t), 3);
          y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          z = p * 4 - 6; // Extrude slightly

          // Normalize and scale
          x *= 0.2; y *= 0.2; z = (Math.random() - 0.5) * 2;
        }
        else if (shape === 'sphere' || shape === 'fireworks') {
          const p = getPointOnSphere(shape === 'fireworks' ? 0.1 : 3.5);
          x = p.x; y = p.y; z = p.z;
          if (shape === 'fireworks') {
            // Explosion vectors stored in target, logic handles expansion in loop
            const expl = getPointOnSphere(3 + Math.random() * 5);
            x = expl.x; y = expl.y; z = expl.z;
          }
        }
        else if (shape === 'saturn') {
          const r = Math.random();
          if (r < 0.6) {
            // Planet Body
            const p = getPointOnSphere(2);
            x = p.x; y = p.y; z = p.z;
          } else {
            // Rings
            const ang = Math.random() * Math.PI * 2;
            const dist = 3 + Math.random() * 2.5;
            x = Math.cos(ang) * dist;
            z = Math.sin(ang) * dist;
            y = (Math.random() - 0.5) * 0.1;

            // Tilt
            const tilt = 0.4;
            const _y = y * Math.cos(tilt) - z * Math.sin(tilt);
            const _z = y * Math.sin(tilt) + z * Math.cos(tilt);
            y = _y; z = _z;
          }
        }
        else if (shape === 'flower') {
          const u = Math.random() * Math.PI * 2;
          const v = Math.random() * Math.PI;
          const r = 3 + Math.sin(5 * u) * Math.sin(4 * v);
          x = r * Math.sin(v) * Math.cos(u);
          y = r * Math.sin(v) * Math.sin(u);
          z = r * Math.cos(v);
        }
        else if (shape === 'buddha') {
          // Procedural "Meditating Figure" approximation
          // Stacked spheres/ovals
          const r = Math.random();
          let p;
          if (r < 0.25) { // Head
            p = getPointOnSphere(0.8);
            x = p.x; y = p.y + 2.5; z = p.z;
          } else if (r < 0.65) { // Body
            p = getPointOnSphere(1.6);
            x = p.x * 1.2; y = p.y * 1.3; z = p.z * 0.9;
          } else { // Legs/Base (Lotus position approximation)
            p = getPointOnSphere(2.2);
            x = p.x * 1.5; y = (p.y * 0.5) - 1.5; z = p.z * 1.2;
          }
        }

        newArr[idx] = x;
        newArr[idx + 1] = y;
        newArr[idx + 2] = z;
      }
      return newArr;
    }

    // --- 5. LOGIC & ANIMATION ---

    function setShape(shape) {
      currentShape = shape;

      // Update buttons UI
      document.querySelectorAll('.shape-grid button').forEach(b => b.classList.remove('active'));
      document.getElementById(`btn-${shape}`).classList.add('active');

      // Generate new targets
      const newTargets = generateShapePositions(shape);
      for (let i = 0; i < targetPositions.length; i++) {
        targetPositions[i] = newTargets[i];
      }
    }

    // Initial generation
    setShape('heart');

    // Color Picker Logic
    const colorPicker = document.getElementById('color-picker');
    colorPicker.addEventListener('input', (e) => {
      material.color.set(e.target.value);
    });

    // Animation Loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();
      const positionsAttr = particles.geometry.attributes.position;
      const currentPos = positionsAttr.array;

      // Hand Interaction Logic
      // If hand is closed (factor -> 0), scale drops to small. If open (factor -> 1), scale is 1.
      // We map 0..1 to 0.1..1.5
      const scaleFactor = 0.1 + (handInteractionFactor * 1.4);

      // Basic Rotation
      particles.rotation.y += 0.002;
      if (currentShape === 'saturn') particles.rotation.z = 0.2;
      else particles.rotation.z = 0;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const ix = i * 3;
        const iy = i * 3 + 1;
        const iz = i * 3 + 2;

        // Get target
        const tx = targetPositions[ix];
        const ty = targetPositions[iy];
        const tz = targetPositions[iz];

        // Lerp towards target (Morphing effect)
        // We add some noise based on time for "aliveness"
        const noise = Math.sin(time + i) * 0.02;

        // Apply Hand Scale to Target
        const scaledTx = tx * scaleFactor;
        const scaledTy = ty * scaleFactor;
        const scaledTz = tz * scaleFactor;

        // Move current pos to target
        currentPos[ix] += (scaledTx - currentPos[ix]) * 0.05 + noise;
        currentPos[iy] += (scaledTy - currentPos[iy]) * 0.05 + noise;
        currentPos[iz] += (scaledTz - currentPos[iz]) * 0.05 + noise;
      }

      positionsAttr.needsUpdate = true;
      renderer.render(scene, camera);
    }

    animate();

    // --- 6. MEDIAPIPE HAND TRACKING ---

    const videoElement = document.getElementById('video-feed');
    const statusText = document.getElementById('status-text');
    const camDot = document.getElementById('cam-dot');

    function onResults(results) {
      camDot.classList.add('active');

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        statusText.innerText = "Hand detected";
        const landmarks = results.multiHandLandmarks[0];

        // Calculate "Tension" / Openness
        // We measure distance between Index Finger Tip (8) and Wrist (0)
        // and Thumb Tip (4) and Pinky Tip (20) to approximate openness.

        // Simplified: Average distance of tips from wrist
        const wrist = landmarks[0];
        const tips = [4, 8, 12, 16, 20]; // Fingertips
        let totalDist = 0;

        tips.forEach(idx => {
          const tip = landmarks[idx];
          const d = Math.sqrt(
            Math.pow(tip.x - wrist.x, 2) +
            Math.pow(tip.y - wrist.y, 2)
          );
          totalDist += d;
        });

        const avgDist = totalDist / 5;

        // Calibration: 
        // Closed fist usually has avgDist around 0.1 - 0.2
        // Open hand usually around 0.4 - 0.6
        // Normalize this to 0 (closed) to 1 (open)

        const minVal = 0.15;
        const maxVal = 0.45;
        let normalized = (avgDist - minVal) / (maxVal - minVal);

        // Clamp
        if (normalized < 0) normalized = 0;
        if (normalized > 1) normalized = 1;

        // Smooth transition
        handInteractionFactor += (normalized - handInteractionFactor) * 0.1;

      } else {
        statusText.innerText = "No hand detected";
        // Slowly return to open state if no hand
        handInteractionFactor += (1.0 - handInteractionFactor) * 0.05;
      }
    }

    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraFeed = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 320,
      height: 240
    });

    cameraFeed.start()
      .then(() => {
        statusText.innerText = "Camera active. Show hand.";
      })
      .catch(err => {
        statusText.innerText = "Camera Error: " + err.message;
        console.error(err);
      });

    // Resize Handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>

</html>